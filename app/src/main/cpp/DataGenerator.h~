#ifndef DATAGENERATOR_H
#define DATAGENERATOR_H



#include "mouse.h"
#include "tspline/tessellator.h"



  //load T-spline model
  //SimpleDemoPtr demo = makePtr<SimpleDemo>();
  MouseDemoPtr demo = makePtr<MouseDemo>();
  TSplinePtr spline = demo->findTSpline();
  std::string splinename = spline->getName();
  TTessellator tessellator(spline);
  //tessellator.setResolution(0.05);
  // TriMeshPtr trimesh = tessellator.interpolateAll();
  TImagePtr image = spline->getTImage();
  TFacVIterator fiter = image->faceIteratorBegin();
  TFacePtr tface = *fiter;

  TriMeshPtr trimesh = tessellator.interpolateFace(tface);

  // Create Index buffer
  num_indices_ = trimesh->sizePoints();
  uint16_t  tsplineIndices[num_indices_];
   TriVIterator titer = trimesh->triangleIteratorBegin();
   for (int32_t i = 0; titer != trimesh->triangleIteratorEnd(); titer++, i++) {
     tsplineIndices[i] = (*titer)->point_indices[0];
     tsplineIndices[i+1] = (*titer)->point_indices[1];
     tsplineIndices[i+2] = (*titer)->point_indices[2];
   }
  glGenBuffers(1, &ibo_);
  glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ibo_);
  glBufferData(GL_ELEMENT_ARRAY_BUFFER, trimesh->sizePoints(), tsplineIndices,
               GL_STATIC_DRAW);
  glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);

  // Create VBO



  num_vertices_ = trimesh->sizePoints();
  int32_t stride = sizeof(TEAPOT_VERTEX);
  int32_t index = 0;
  TEAPOT_VERTEX* p = new TEAPOT_VERTEX[num_vertices_];
  int32_t i = 0;
  TriVIterator iter;
  for (iter=trimesh->triangleIteratorBegin();iter!=trimesh->triangleIteratorEnd();iter++)
  {
    TrianglePtr triangle = *iter;
    Word v0 = triangle->point_indices[0];
    Word v1 = triangle->point_indices[1];
    Word v2 = triangle->point_indices[2];
    Point3DPtr point0 = trimesh->pointAt(v0);
    Point3DPtr point1 = trimesh->pointAt(v1);
    Point3DPtr point2 = trimesh->pointAt(v2);

    Vector3DPtr norm0 = trimesh->normAt(v0);
    Vector3DPtr norm1 = trimesh->normAt(v1);
    Vector3DPtr norm2 = trimesh->normAt(v2);


      p[i].pos[0] = point0->x();
      p[i].pos[1] = point0->y();
      p[i].pos[2] = point0->z();

      p[i].normal[0] = norm0->i();
      p[i].normal[1] = norm0->j();
      p[i].normal[2] = norm0->k();

    i+=1;

    p[i].pos[0] = point1->x();
    p[i].pos[1] = point1->y();
    p[i].pos[2] = point1->z();

    p[i].normal[0] = norm1->i();
    p[i].normal[1] = norm1->j();
    p[i].normal[2] = norm1->k();

    i+=1;

    p[i].pos[0] = point2->x();
    p[i].pos[1] = point2->y();
    p[i].pos[2] = point2->z();

    p[i].normal[0] = norm2->i();
    p[i].normal[1] = norm2->j();
    p[i].normal[2] = norm2->k();

    i+=1;

    //vertices.push_back(point0->x());
    //vertices.push_back(point0->y());
    //vertices.push_back(point0->z());

  }




   // N3dVIterator niter = trimesh->normalIteratorBegin();
   // for (int32_t i = 0; niter != trimesh->normalIteratorEnd(); niter++, i++) {
   //   p[i].normal[0] = (*niter)->i();
   //   p[i].normal[1] = (*niter)->j();
    //  p[i].normal[2] =(*niter)->k();
   // }

   // TriVIterator titer = trimesh->triangleIteratorBegin();
   // for (; titer != trimesh->triangleIteratorEnd(); titer++) {
   //   face.push_back((*titer)->point_indices[0]);
   //   face.push_back((*titer)->point_indices[1]);
   //   face.push_back((*titer)->point_indices[2]);
   // }

  ///////////////////////////////////////////////////////////////

  ///*
 /* num_vertices_ = sizeof(teapotPositions) / sizeof(teapotPositions[0]) / 3;
  int32_t stride = sizeof(TEAPOT_VERTEX);
  int32_t index = 0;
  TEAPOT_VERTEX* p = new TEAPOT_VERTEX[num_vertices_];
  for (int32_t i = 0; i < num_vertices_; ++i) {
    p[i].pos[0] = teapotPositions[index];
    p[i].pos[1] = teapotPositions[index + 1];
    p[i].pos[2] = teapotPositions[index + 2];

    p[i].normal[0] = teapotNormals[index];
    p[i].normal[1] = teapotNormals[index + 1];
    p[i].normal[2] = teapotNormals[index + 2];
    index += 3;
  }*/


#endif

